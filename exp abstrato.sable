Package calculadora;

Helpers
 digito = ['0' .. '9'];
 espaco = ' ';
 tab = 9;
 rc = 13;
 nl = 10;
 under = '_';
 letra =['a'..'z'] | ['A'..'Z'];
 aspa = 39;
 tudo = [0 .. 0xFFFF];
 tudomenosfecha = [tudo-'}'];
 tudomenosaspa = [tudo-aspa];
 tudomenosnl = [tudo-nl];
 cominicio = '{';
 comfim = '}';
 
Tokens
 pontovirgula = ';';
 doispontos = ':';
 separador = '|';
 atribuidor = '<<';
 
 variavel = 'var';
 constante = 'const';
 tipoint = 'inteiro';
 tiporeal = 'real';
 tipocadeia = 'cadeia';
 tipobooleano = 'booleano';
 
 se = 'se';
 senao = 'senao';
 enquanto = 'enquanto';
 
 imprima ='imprima';
 leia ='leia';
 size ='size';
 
 principal = '>>';
 procedimento ='procedimento';
 funcao = 'funcao';
 comece ='comece';
 termine ='termine';
 
 booleano ='verdade'|'falso';
 cadeia=aspa tudomenosaspa* aspa;
 binario = '0b' ('0'|'1')+;
 real = digito+ ',' digito+;
 numero = digito+;
 
 soma = '+';
 menos = '-';
 mult = '*';
 div = '/';
 mod = '%';
 
 igual = '=';
 maior = '>';
 maiorigual = '>=';
 e = 'e';
 nao = 'nao';
 ou = 'ou';
 
 par_esq = '(';
 par_dir = ')';
 chave_esq = '[';
 chave_dir = ']';
 
 identificador = (letra | under) (letra | under | digito)*;
 vazio = (espaco | rc | nl | tab)+;
 comlinha ='--' tudomenosnl*;
 combloco = (cominicio) (tudomenosfecha)* (comfim);
 


Ignored Tokens
 vazio,
 comlinha,
 combloco;
 
Productions 

    programa
         {-> P.programa  } =

     {aprograma1} P.a_func_e_proc 
         {-> New programa ([  ], [ a_func_e_proc.func_e_proc  ] )  }   |

     {aprograma2} P.a_var_const P.a_func_e_proc 
         {-> New programa ([ a_var_const.var_const  ], [ a_func_e_proc.func_e_proc  ] )  }  
     ;

    var_const
         {-> P.var_const  } =

     {numero} dec_var 
         {-> New var_const.numero (dec_var  )  }   |

     {bool} dec_cons 
         {-> New var_const.bool (dec_cons  )  }  
     ;

    func_e_proc
         {-> P.func_e_proc  } =

     {funcao} dec_funcao 
         {-> New func_e_proc.funcao (dec_funcao  )  }   |

     {proc} dec_procedimento 
         {-> New func_e_proc.proc (dec_procedimento  )  }  
     ;

    dec_funcao
         {-> P.dec_funcao  } =

     funcao doispontos tiporetorno identificador par_esq parametros par_dir exp 
         {-> New dec_funcao (funcao , doispontos , tiporetorno , identificador , par_esq , parametros , par_dir , exp.a_exp)  }  
     ;

    dec_procedimento
         {-> P.dec_procedimento  } =

     {asimplesdecprocedimento1} procedimento doispontos identificador par_esq parametros par_dir exp 
         {-> New dec_procedimento.simples (Null , procedimento , doispontos , identificador , par_esq , parametros , par_dir , exp.a_exp  )  }   |

     {asimplesdecprocedimento2} principal procedimento doispontos identificador par_esq parametros par_dir exp 
         {-> New dec_procedimento.simples (principal , procedimento , doispontos , identificador , par_esq , parametros , par_dir , exp.a_exp  )  }  
     ;

    parametros
         {-> P.parametros  } =

     {aparametrosparametros1} parametro 
         {-> New parametros.parametros (parametro , [  ] )  }   |

     {aparametrosparametros2} parametro P.a_maisparametros 
         {-> New parametros.parametros (parametro , [ a_maisparametros.maisparametros  ] )  }   |

     {vazio} 
         {-> New parametros.vazio ( )  }  
     ;

    parametro
         {-> P.parametro  } =

     tipo_parametro identificador 
         {-> New parametro (tipo_parametro , identificador  )  }  
     ;

    maisparametros
         {-> P.maisparametros  } =

     separador parametro 
         {-> New maisparametros (separador , parametro  )  }  
     ;

    tipo_parametro
         {-> P.tipo_parametro  } =

     {base} tipo_base 
         {-> New tipo_parametro.base (tipo_base  )  }   |

     tipo_parametro chave_esq chave_dir 
         {-> New tipo_parametro (tipo_parametro , chave_esq , chave_dir  )  }  
     ;

    tipo
         {-> P.tipo  } =

     {base} tipo_base 
         {-> New tipo.base (tipo_base  )  }   |

     {vetor} tipo chave_esq exp chave_dir 
         {-> New tipo.vetor (tipo , chave_esq , exp.a_exp , chave_dir  )  }  
     ;

    tiporetorno
         {-> P.tiporetorno  } =

     {base} tipo_base 
         {-> New tiporetorno.base (tipo_base  )  }   |

     {vetor} tiporetorno chave_esq chave_dir 
         {-> New tiporetorno.vetor (tiporetorno , chave_esq , chave_dir  )  }  
     ;

    tipo_base
         {-> P.tipo_base  } =

     {inteiro} tipoint 
         {-> New tipo_base.inteiro (tipoint  )  }   |

     {real} tiporeal 
         {-> New tipo_base.real (tiporeal  )  }   |

     {cadeia} tipocadeia 
         {-> New tipo_base.cadeia (tipocadeia  )  }   |

     {booleano} tipobooleano 
         {-> New tipo_base.booleano (tipobooleano  )  }  
     ;

    dec_cons
         {-> P.dec_cons  } =

     constante doispontos tipo id_atribuicao pontovirgula 
         {-> New dec_cons (constante , doispontos , tipo , id_atribuicao , pontovirgula  )  }  
     ;

    dec_var
         {-> P.dec_var  } =

     variavel doispontos tipo id_ou_id_atri pontovirgula 
         {-> New dec_var (variavel , doispontos , tipo , id_ou_id_atri , pontovirgula  )  }  
     ;

    id_ou_id_atri
         {-> P.id_ou_id_atri  } =

     {id} identificador 
         {-> New id_ou_id_atri.id (identificador  )  }   |

     {id_a} id_atribuicao 
         {-> New id_ou_id_atri.id_a (id_atribuicao  )  }  
     ;
	
    exp	{-> a_exp  } =

     {fator} fator {-> fator.a_exp}   |

     {arraycomp} array_comp {-> New a_exp.a_arraycomp (array_comp)}   |

     {negativo} menos exp {-> New a_exp.a_negativo (exp.a_exp)}   |

     {seternario} seternario {-> New a_exp.a_seternario (seternario)}   |

     {bloco} bloco_expressoes {-> New a_exp.a_bloco (bloco_expressoes)}  
     ;

    fator  {-> a_exp  } =

     {termo} termo {-> termo.a_exp}   |

     {soma} fator soma termo {-> New a_exp.a_soma (fator.a_exp , termo.a_exp  )  }   |

     {menos} fator menos termo {-> New a_exp.a_menos (fator.a_exp , termo.a_exp)  }   |

     {mult} fator mult termo {-> New a_exp.a_mult (fator.a_exp , termo.a_exp)  }   |

     {div} fator div termo {-> New a_exp.a_div (fator.a_exp , termo.a_exp)  }   |

     {mod} fator mod termo {-> New a_exp.a_mod (fator.a_exp , termo.a_exp)  }   |

     {igual} fator igual termo {-> New a_exp.a_igual (fator.a_exp , termo.a_exp)  }   |

     {maiorigual} fator maiorigual termo {-> New a_exp.a_maiorigual (fator.a_exp , termo.a_exp)  }   |

     {maior} fator maior termo {-> New a_exp.a_maior (fator.a_exp , termo.a_exp)  }   |

     {e} fator e termo {-> New a_exp.a_e (fator.a_exp , termo.a_exp)  }   |

     {ou} fator ou termo {-> New a_exp.a_ou (fator.a_exp , termo.a_exp)  }  
     ;

    termo	{-> a_exp  } =

     {int} numero {-> New a_exp.a_int (numero)  }   |

     {binario} binario {-> New a_exp.a_binario (binario)  }   |

     {real} real {-> New a_exp.a_real (real)  }   |

     {cadeia} cadeia {-> New a_exp.a_cadeia (cadeia)  }   |

     {booleano} booleano {-> New a_exp.a_booleano (booleano)  }   |

     {variavel} valor {-> New a_exp.a_variavel (valor.a_valor)  }   |

     {cham_func} chamadafuncao {-> New a_exp.a_cham_func (chamadafuncao)  }   |

     {par} par_esq exp par_dir {-> exp.a_exp}   |

     {nao} nao termo {-> New a_exp.a_nao (termo.a_exp)  }  
     ;

    valor	{-> a_valor  } =

     {variavel} identificador {-> New a_valor.a_variavel (identificador)  }   |

     {vetor} valor chave_esq exp chave_dir {-> New a_valor.a_vetor (valor.a_valor,exp.a_exp )  }  
     ;

    chamadafuncao
         {-> P.chamadafuncao  } =

     {leia} leia par_esq par_dir 
         {-> New chamadafuncao.leia (leia)  }   |

     {size} size par_esq lista_exp par_dir 
         {-> New chamadafuncao.size (size ,lista_exp)  }   |

     {id} identificador par_esq lista_exp par_dir 
         {-> New chamadafuncao.id (identificador  , lista_exp )  }  
     ;

    lista_exp
         {-> P.lista_exp  } =

     {aexpressoeslistaexp1} exp 
         {-> New lista_exp.expressoes (exp.a_exp , [  ] )  }   |

     {aexpressoeslistaexp2} exp P.a_maisexp 
         {-> New lista_exp.expressoes (exp.a_exp , [ a_maisexp.maisexp  ] )  }   |

     {vazio} 
         {-> New lista_exp.vazio ( )  }  
     ;

    maisexp
         {-> P.maisexp  } =

     separador exp 
         {-> New maisexp (separador , exp.a_exp  )  }  
     ;

	array_comp {-> P.array_comp  } =
	
	 chave_esq identificador separador exp chave_dir 
	     {-> New array_comp (identificador , exp.a_exp)  }  
	 ;

    seternario {-> P.seternario  } =

     se par_esq exp par_dir [verdade]: exp senao [falso]: exp 
         {-> New seternario (exp.a_exp ,verdade.a_exp , falso.a_exp  )  }  
     ;

    bloco_expressoes {-> P.bloco_expressoes  } =

     {ablocoexpressoes1} comece exp termine 
         {-> New bloco_expressoes ([  ], exp.a_exp)  }   |

     {ablocoexpressoes2} comece P.a_dec_cons exp termine 
         {-> New bloco_expressoes ([ a_dec_cons.dec_cons  ], exp.a_exp)  }  
     ;

    id_atribuicao {-> P.id_atribuicao  } =

     valor atribuidor exp 
         {-> New id_atribuicao (valor.a_valor , exp.a_exp  )  }  
     ;

    a_func_e_proc
         {-> P.func_e_proc*  } =

     {terminal} P.func_e_proc 
         {-> [ P.func_e_proc.func_e_proc  ]  }   |

     {non_terminal} P.a_func_e_proc P.func_e_proc 
         {-> [ a_func_e_proc.func_e_proc, P.func_e_proc.func_e_proc  ]  }  
     ;

    a_var_const
         {-> P.var_const*  } =

     {terminal} P.var_const 
         {-> [ P.var_const.var_const  ]  }   |

     {non_terminal} P.a_var_const P.var_const 
         {-> [ a_var_const.var_const, P.var_const.var_const  ]  }  
     ;

    a_maisparametros
         {-> P.maisparametros*  } =

     {terminal} P.maisparametros 
         {-> [ P.maisparametros.maisparametros  ]  }   |

     {non_terminal} P.a_maisparametros P.maisparametros 
         {-> [ a_maisparametros.maisparametros, P.maisparametros.maisparametros  ]  }  
     ;

    a_maisexp
         {-> P.maisexp*  } =

     {terminal} P.maisexp 
         {-> [ P.maisexp.maisexp  ]  }   |

     {non_terminal} P.a_maisexp P.maisexp 
         {-> [ a_maisexp.maisexp, P.maisexp.maisexp  ]  }  
     ;

    a_dec_cons
         {-> P.dec_cons*  } =

     {terminal} P.dec_cons 
         {-> [ P.dec_cons.dec_cons  ]  }   |

     {non_terminal} P.a_dec_cons P.dec_cons 
         {-> [ a_dec_cons.dec_cons, P.dec_cons.dec_cons  ]  }  
     ;

Abstract Syntax Tree
    programa =
     var_const* func_e_proc+ 
     ;

    var_const =
     {numero} dec_var | 
     {bool} dec_cons 
     ;

    func_e_proc =
     {funcao} dec_funcao | 
     {proc} dec_procedimento 
     ;

    dec_funcao =
     funcao doispontos tiporetorno identificador par_esq parametros par_dir a_exp 
     ;

    dec_procedimento =
     {simples} principal? procedimento doispontos identificador par_esq parametros par_dir a_exp 
     ;

    parametros =
     {parametros} parametro maisparametros* | 
     {vazio} 
     ;

    parametro =
     tipo_parametro identificador 
     ;

    maisparametros =
     separador parametro 
     ;

    tipo_parametro =
     {base} tipo_base | 
     tipo_parametro chave_esq chave_dir 
     ;

    tipo =
     {base} tipo_base | 
     {vetor} tipo chave_esq a_exp chave_dir 
     ;

    tiporetorno =
     {base} tipo_base | 
     {vetor} tiporetorno chave_esq chave_dir 
     ;

    tipo_base =
     {inteiro} tipoint | 
     {real} tiporeal | 
     {cadeia} tipocadeia | 
     {booleano} tipobooleano 
     ;

    dec_cons =
     constante doispontos tipo id_atribuicao pontovirgula 
     ;

    dec_var =
     variavel doispontos tipo id_ou_id_atri pontovirgula 
     ;

    id_ou_id_atri =
     {id} identificador | 
     {id_a} id_atribuicao 
     ;
     
    a_exp = 
      {a_arraycomp} array_comp 
     | {a_negativo} a_exp 
     | {a_seternario} seternario  
     | {a_bloco} bloco_expressoes 
     | {a_soma} [esq]:a_exp [dir]:a_exp
     | {a_menos} [esq]:a_exp [dir]:a_exp
     | {a_mult} [esq]:a_exp [dir]:a_exp
     | {a_div} [esq]:a_exp [dir]:a_exp
     | {a_mod} [esq]:a_exp [dir]:a_exp
     | {a_igual} [esq]:a_exp [dir]:a_exp
     | {a_maiorigual} [esq]:a_exp [dir]:a_exp
     | {a_maior} [esq]:a_exp [dir]:a_exp
     | {a_e} [esq]:a_exp [dir]:a_exp
     | {a_ou} [esq]:a_exp [dir]:a_exp
     | {a_int} numero
     | {a_binario} binario 
     | {a_real} real 
     | {a_cadeia} cadeia 
     | {a_booleano} booleano 
     | {a_variavel} a_valor
     | {a_cham_func} chamadafuncao 
     | {a_nao} a_exp
	 ;

     a_valor =
     {a_variavel} identificador | 
     {a_vetor} a_valor a_exp  
     ;

    chamadafuncao =
     {leia} leia | 
     {size} size lista_exp | 
     {id} identificador lista_exp 
     ;

    lista_exp =
     {expressoes} a_exp maisexp* | 
     {vazio} 
     ;

    maisexp =
     separador a_exp 
     ;

    array_comp =
      identificador a_exp  
     ;

    seternario =
      a_exp [verdade]: a_exp [falso]: a_exp 
     ;

    bloco_expressoes =
     dec_cons* a_exp 
     ;

    id_atribuicao =
     a_valor a_exp
     ;
 